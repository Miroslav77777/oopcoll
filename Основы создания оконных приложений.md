
Для создания оконных приложений есть две библиотеки, Swing и AWT

## AWT

AWT API в Java в основном состоит из полного набора классов и методов, которые необходимы для упрощенного создания и управления графическим интерфейсом пользователя (GUI). Он был разработан для предоставления общего набора инструментов для проектирования кроссплатформенных графических интерфейсов.

Одной из важных особенностей AWT является то, что он зависит от платформы. Это означает, что инструменты AWT используют нативные наборы инструментов платформ, которые они внедряют.

Этот подход помогает сохранить внешний вид каждой платформы. Но, как уже говорилось, все идет с ценой, у этого подхода есть существенный недостаток. При выполнении на разных платформах из-за зависимости платформы она будет выглядеть по-разному на каждой платформе. Это затрудняет согласованность и эстетику приложения.

### AWT Компоненты

#### 1. Контейнеры
Контейнер в Java AWT — это компонент, который используется для хранения других компонентов, таких как текстовые поля, кнопки и т. д. Он является подклассом java.awt.Component и отвечает за отслеживание добавляемых компонентов. AWT в Java предоставляет четыре типа контейнеров.

#### Типы Контейнеров

#### 2. Кнопка
Класс java.awt.Button используется для создания помеченной кнопки. Компонент графического интерфейса, который запускает определенный запрограммированный при нажатии на него. Класс Button имеет два конструктора:

```java
//Construct a Button with the given label
public Button(String btnLabel);

//Construct a Button with empty label
public Button();
```

Несколько методов, предоставляемых этим классом, перечислены ниже:

```java
//Get the label of this Button instance
public String getLabel();

//Set the label of this Button instancenbsp;nbsp;nbsp;
public void setLabel(String btnLabel);

//Enable or disable this Button. Disabled Button cannot be clicked
public void setEnable(boolean enable);
```

#### 3. Текстовое поле
Класс java.awt.TextField создает однострочное текстовое поле для ввода текста пользователями. Класс TextField имеет три конструктора:

```java
//Construct a TextField instance with the given initial text string with the number of columns.
public TextField(String initialText, int columns);

//Construct a TextField instance with the given initial text string.
public TextField(String initialText);

//Construct a TextField instance with the number of columns.
public TextField(int columns);
```

Вот несколько методов, предоставляемых классом TextField:

```java
// Get the current text on this TextField instance
public String getText();

// Set the display text on this TextField instance
public void setText(String strText);
//Set this TextField to editable (read/write) or non-editable (read-only)
public void setEditable(boolean editable);
```

#### 4. Метка
Класс java.awt.Label предоставляет текстовую строку с описанием, видимую в графическом интерфейсе. Объект метки AWT — это компонент для размещения текста в контейнере. Класс Label имеет три конструктора:

```java
// Construct a Label with the given text String, of the text alignment
public Label(String strLabel, int alignment); 

//Construct a Label with the given text String
public Label(String strLabel);

//Construct an initially empty Label
public Label();
```

Этот класс также предоставляет 3 константы:

```java
public static final LEFT; // Label.LEFT

public static final RIGHT;  // Label.RIGHT

public static final CENTER; // Label.CENTER
Источник: https://java-blog.ru/osnovy/java-awt
```

Ниже я перечислил открытые методы, предоставляемые этим классом:

```java
public String getText();

public void setText(String strLabel);

public int getAlignment();

//Label.LEFT, Label.RIGHT, Label.CENTER 
public void setAlignment(int alignment);
```

#### 5. Холст
Класс Canvas представляет прямоугольную область, в которой вы можете рисовать в приложении или получать входные данные, созданные пользователем.

#### 6. Выбор
Класс выбора используется для представления всплывающего меню выбора. Выбранный вариант отображается в верхней части данного меню.

#### 7. Полоса прокрутки
Объект класса Scrollbar используется для добавления горизонтальной и вертикальной полосы прокрутки в GUI. Это позволяет пользователю видеть невидимое количество строк и столбцов.

#### 8. Список
Объект класса List представляет собой список текстовых элементов. Используя класс List, пользователь может выбрать либо один элемент, либо несколько элементов.

#### 9. CheckBox
Флажок представляет собой класс графического компонента, который используется для создания флажка. У него есть два варианта состояния; правда и ложь. В любой момент времени он может иметь любой из двух.

## Swing

Компоненты swing имеют расширенные возможности по сравнению с аналогичными awt компонентами. Во-вторых, в отличие от awt компоненты swing не содержат платформо-зависимого кода. Так сказать являются _облегченными (lightweight) компонентами_.

### контейнеры верхнего уровня

- _JApplet_ — главное окно апплета;
- _JFrame_ — окно приложения;
- _JDialog_ — диалог приложения.
- _JColorChooser_ — диалог выбора цвета;
- _JFileChooser_ — диалог выбора файлов и директорий;
- _FileDialog_ — диалог выбора файлов и директорий (awt компонент).

### простые контейнеры

- _JPanel_ — простая панель для группировки элементов, включая вложенные панели;
- _JToolBar_ — панель инструментов (обычно это кнопки);
- _JScroolPane_ — панель прокрутки, позволяющая прокручивать содержимое дочернего элемента;
- _JDesktopPane_ — контейнер для создания виртуального рабочего стола или приложений на основе MDI (multiple-document interface);
- _JEditorPane, JTextPane_ — контейнеры для отображения сложного документа как HTML или RTF;
- _JTabbedPane_ — контейнер для управления закладками;
- _JSplitPane_ — контейнер, разделяющий два элемента и позволяющий пользователю изменять их размер.

### элементы интерфейса

Следующие элементы управления могут использоваться и как контейнеры, так как наследуются от класса java.awt.Container.

- _JButton_ — кнопка;
- _JCheckBox_ — кнопка-флажок;
- _JComboBox_ — выпадающий список;
- _JLabel_ — метка, надпись;
- _JList_ — список;
- _JPasswordField_ — текстовое поле для скрытого ввода;
- _JProgressBar_ — компонент для отображения числа в некотором диапазоне;
- _JRadioButton_ — преключатели, радио-кнопки, обычно используется с  
    компонентом ButtonGroup;
- _JSlider_ — компонент позволяющий выбрать значение из заданного диапазона;
- _JSpinner_ — компонент позволяющий выбрать значение из указанной последовательности;
- _JTable_ — таблица;
- _JTextField_ — однострочное текстовое поле;
- _JTextArea_ — многострочное текстовое поле;
- _JTree_ — дерево.

### управление позиционированием и размерами

Для автоматического позиционирования и задания размеров дочерних элементов контейнерыиспользуют специальные объекты — _компоновщики_. Для ручного позиционирования надо установить пустой объект вызовом метода setLayout(null).

Ниже приведен список стандартных компоновщиков:

- _BorderLayout_ — размещает элементы в один из пяти регионов, как было указано при добавлении элемента в контейнер:  
    наверх, вниз, влево, вправо, в центр;
- _FlowLayout_ — размещает элементы по порядку в том же направлении, что и ориентация контейнера (слева на право по умолчанию)  
    применяя один из пяти видов выравнивания, указанного при создании менеджера.  
    Данный менеджер используется по умолчанию в большинстве контейнерах;
- _GridLayout_ — размещает элементы таблично. Колличество столбцов и строк указывается  
    при создании менеджера. По умолчанию одна строка, а число столбцов равно числу элементов;
- _BoxLayout_ — размещает элементы по вертикали или по горизонтали. Обычно он используется не  
    напрямую а через контейнерный класс Box, который имеет дополнительные возможности;
- _SpringLayout_ — это менеджер низкого уровня и был разработан для программ  
    построителей форм;
- _GroupLayout_ — данный менеджер также был разработан для построителей форм.

### события

Элементы интерфейса и контейнеры генерируют ряд событий, например:

- _ActionEvent_ — событие, определяемое компонентом, например нажатие кнопки;
- _ComponentEvent_ — генерируется, когда позиция, размер или видимость компонента изменяются;
- _ContainerEvent_ — генерируется при добавлении или удалении элемента из контейнера;
- _FocusEvent_ — генерируется при получении или потери фокуса ввода компонентом;
- _ItemEvent_ — событие выбора или отменены выбора элемента.  
    Например, изменение состояния кнопки-флажка, выбор элемента меню или списка;
- _KeyEvent_ — событие ввода с клавиатуры;
- _MouseEvent_ — события мыши;
- _WindowEvent_ — события окна, как активация и свертывание.

Для обработки событий элемента в нем необходимо зарегистрировать объект обработчик  
в числе слушателей. Делается это методами типа addxxxListener, например addMouseListener(). В качестве объектов обработчиков обычно выбирают контейнер, в котором содержится элемент.Обработка события осуществляется через соответствующий интерфейс, например:

- _ActionListener_ — интерфейс обработки события ActionEvent;
- _ItemListener_ — интерфейс обработки события ItemEvent;
- _KeyListener_ — интерфейс обработки события KeyEvent;
- _MouseListener_ — интерфейс обработки события MouseEvent, для нажатия/отжатия кнопок и входа/ухода курсора мыши с  
    области компонента;
- _MouseMotionListener_ — интерфейс обработки события MouseEvent, для движение курсора мыши или перетаскивании мышью;
- _MouseWheelListener_ — интерфейс обработки события MouseEvent, для прокрутки  
    колеса мыши.

Если весь интерфейс реализовывать не нужно, например, нужен только  
один из методов, то можно воспользоваться адаптерами.

## Компоновщики

Менеджеры компоновки используются для автоматического позиционирования и задания размеров дочерних элементов в контейнере. Компоновщиком является любой объект реализующий интерфейс LayoutManager или LayoutManager2 (поддерживает выравнивание и ограничения).

### стандартные компоновщики

- _BorderLayout_ — размещает элементы в один из пяти регионов, как было указано при добавлении элемента в контейнер: наверх, вниз, влево, вправо, в центр. По умолчанию элемент добавляется в центр. Если в указанном регионе уже есть элемент, то он замещается новым. Поэтому, когда надо разместить несколько элементов в одном регионе, то их объединяют в один контейнер (обычно JPanel);
- _FlowLayout_ — размещает элементы по порядку в том же направлении, что  
    и ориентация контейнера (слева на право по умолчанию)  
    применяя один из пяти видов выравнивания, указанного при создании менеджера.  
    Данный менеджер используется по умолчанию;
- _GridLayout_ — размещает элементы таблично. Колличество столбцов и строк указывается при создании менеджера. По умолчанию одна строка, а число столбцов равно числу элементов. Вся область контейнера разбивается на ячейки и размер каждого элемента устанавливается в размерячейки. Это больше подходит для выравнивания панелей и других контейнеров, а не элементов управления (нам ведь не нужны гигантские кнопки);
- _BoxLayout_ — размещает элементы по вертикали или по горизонтали.  
    Обычно он используется не напрямую, а через контейнерный класс Box (ящик).

### точное позиционирование и задание размеров

Если в контейнере отсутствует компоновщик (был вызван метод контейнера setLayout(null)), то позицию и размеры элементов необходимо задать явно методами элемента

- _setLocation_(Point p) — переместить компонент в указанную точку;
- _setLocation_(int x, int y) — переместить компонент в указанную точку;
- _setSize_(Dimension d) — установить размеры компонента;
- _setSize_(int width, int height) — установить размеры компонента;
- _setBounds_(Rectangle r) — переместить и установить размеры компонента  
    (вписать в четырехугольник);
- _setBounds_(int x,int y, int width, int height) — переместить и установить  
    размеры компонента.

### предпочтительные размеры

Компоненты обладают минимальными, максимальными и предпочтительными размерами.  
Некоторые компоновщики используют эти параметры, а значит можно повлиять на их работу, изменяя их. Эти размеры также могут пригодится при разработке собственного компоновщика. Если все размеры компонента равны, то говорят, что у компонента фиксированный размер. Получить и установить эти значения можно методами:

- _getMaximumSize_() — получение максимального размера;
- _setMaximumSize_(Dimension d) — установка максимального размера;
- _getMinimumSize_() — получение минимального размера;
- _setMinimumSize_(Dimension d) — установка минимального размера;
- _getPreferredSize_() — получение желательного размера;
- _setPreferredSize_(Dimension d) — установка желательного размера.

### компоновщики низкого уровня

Существует также два компоновщика низкого уровня, разработанных для программ построителей форм SpringLayout и GroupLayout. В  
[документации](https://docs.oracle.com/javase/tutorial/uiswing/layout/spring.html)  
для SpringLayout можно скачать файлик SpringUtilities.java, где реализованы два полезных способа компоновки на его основе (как там сказано просто вызываем методы из этого файла, не вникая в детали:).

### класс Box

_Класс Box_ реализует контейнер с компоновщиком BoxLayout. Если элементы размещаются по горизонтали, то высота всех элементов равна высоте самого высокого элемента.А ширина элементов такова, чтобы заполнить весь контейнер по ширине.  
При изменении ширины контейнера элементы растягиваются пропорционально. Если у всех элементов достигнут предел растяжения (значение getMaximumSize()), то первый элемент растягивается насильно. Если остается хотя бы один элемент доступный для растяжения, то растягивается только он.

Подобным образом происходит и вертикальное размещение. Ширина всех элементов равна ширине самого широкого элемента, а высота элеметов такова, чтобы заполнить весь контейнер по высоте. При этом может понадобится явное задание выравнивания элементов методом setAlignmentX. Иначе даже при одинаковой ширине, элементы не будут выстроены в красивый столбик.

Класс Box имеет статические методы для создания невидимых элементов для различных целей:

- _createHorizontalStrut_(int width) — создает компонент с фиксированной шириной. При горизонтальной укладке элемент используется чтобы освободить пространство между соседними элементами, иначе элементы будут впритык. При вертикальной укладке элемент используется для задания минимальной ширины остальных элементов;
- _createVerticalStrut_(int height) — создает компонент с фиксированной высотой. При вертикальной укладке элемент используется чтобы освободить пространство между соседними элементами, иначе элементы будут впритык. При горизонтальной укладке элемент используется для задания минимальной высоты остальных элементов;
- _createRigidArea_(Dimension d) — создает невидимый элемент фиксированного размера;
- _createGlue_() — создает невидимый растягиваемый компонент. Используется, чтобы предотвратить насильное растяжение элементов. Например, пусть в контейнере видимые элементы фиксированного размера. Тогда положив данный компонент в начало и в конец контейнера, мы получим центрирование видимых элементов. А если расположить его после каждого видимого, то при увеличении размера контейнера, видимые элементы «разойдутся» друг от друга.

### пример использования компоновщиков

Ниже приведен пример использования некоторых компоновщиков. Цветные бордюры служат для разграничения текстовых полей друг от друга, если вызовы метода createVerticalStrut буду закомментированы.

```java
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.GridLayout;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JPanel;
import javax.swing.JTextArea;

public class MyPanel extends JPanel {
    private static final long serialVersionUID = 1L;
    private String items[] = new String[] { "item1", "item2", 
          "item3", "item4", "item5" };

    public MyPanel() {
        setLayout(new BorderLayout()); // выбираем компоновщик

        // сеточная растановка в два столбца
        // много строк
        JPanel jp = new JPanel();
        jp.setLayout(new GridLayout(0, 2));
        JButton jb;
        JComboBox cb = new JComboBox(items);
        jp.add(cb);
        jb = new JButton("bt1");
        jp.add(jb);
        jb = new JButton("bt2");
        jp.add(jb);
        jb = new JButton("bt3");
        jp.add(jb);
        jb = new JButton("bt4");
        jp.add(jb);

        // укладываем элементы в ящик
        Box bv = new Box(BoxLayout.Y_AXIS);
        // минимальная ширина текстовых полей
        bv.add(Box.createHorizontalStrut(60));

        JTextArea jta = new JTextArea();
        // рамка вокруг текстового поля
        jta.setBorder(BorderFactory.createLineBorder(Color.green));
        bv.add(jta);
        // пустое место в 15 пикселей
        bv.add(Box.createVerticalStrut(15));
        // для эксперемента с размерами
        // jta.setPreferredSize(new Dimension(60,100));
        // jta.setMaximumSize(new Dimension(60,100));
        // jta.setAlignmentX(LEFT_ALIGNMENT); // явно задаем выравнивание

        jta = new JTextArea();
        jta.setBorder(BorderFactory.createLineBorder(Color.green));
        bv.add(jta);
        bv.add(Box.createVerticalStrut(15));

        jta = new JTextArea();
        jta.setBorder(BorderFactory.createLineBorder(Color.green));
        bv.add(jta);
        bv.add(Box.createVerticalStrut(15));

        add(jp); // добавляем панель в центр
        add(bv, BorderLayout.WEST); // добавляем ящик влево
    }
}
```

